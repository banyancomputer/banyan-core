import { CharSize, Msg, PrivateKey, PublicKey, HashAlg, SymmKeyOpts, EccCurve, CipherText } from '../types.js';
/**
 * Sign a message with an ECSDSA private key
 * @param msg The message to sign
 * @param privateKey The private key to use for signing
 * @param charSize The character size to use for normalization
 * @param hashAlg The hash algorithm to use for signing
 * @returns The signature as an ArrayBuffer
 */
export declare function sign(msg: Msg, privateKey: PrivateKey, charSize?: CharSize, hashAlg?: HashAlg): Promise<ArrayBuffer>;
/**
 * Verify a message with an ECDSA public key
 * @param msg The message to verify
 * @param sig The signature to verify
 * @param publicKey The public key to use for verification
 * @param charSize The character size to use for normalization
 * @param hashAlg The hash algorithm to use for verification
 * @returns A promise that resolves to a boolean indicating whether the signature is valid
 */
export declare function verify(msg: Msg, sig: Msg, publicKey: PublicKey, charSize?: CharSize, hashAlg?: HashAlg): Promise<boolean>;
/**
 * Encrypt a message with a shared public key and your own private key
 * @param msg The message to encrypt
 * @param privateKey Your private key
 * @param publicKey The public key to encrypt with
 * @param derivationSalt The salt to use for key derivation
 * @param charSize The character size to use for normalization
 * @param opts The options for encryption
 * @throws {UnsupportedSymmCrypto} If the symmetric algorithm is not supported
 */
export declare function encrypt(msg: Msg, privateKey: PrivateKey, publicKey: PublicKey, derivationSalt: ArrayBuffer, curve?: EccCurve, hashAlg?: HashAlg, charSize?: CharSize, opts?: Partial<SymmKeyOpts>): Promise<ArrayBuffer>;
/**
 * Decrypt a message with a shared public key and your own private key
 * @param msg The message to decrypt
 * @param privateKey Your private key
 * @param publicKey The public key to decrypt with
 * @param derivationSalt The salt to use for key derivation
 * @param curve The curve to use for key derivation
 * @param charSize The character size to use for normalization
 * @param opts The options for decryption
 * @returns The decrypted message as a string
 * @throws {InvalidCipherTextLength} If the cipher text is not the correct length
 * @throws {UnsupportedSymmCrypto} If the symmetric algorithm is not supported
 */
export declare function decrypt(msg: Msg, privateKey: PrivateKey, publicKey: PublicKey, derivationSalt: ArrayBuffer, curve?: EccCurve, hashAlg?: HashAlg, opts?: Partial<SymmKeyOpts>): Promise<ArrayBuffer>;
/**
 * Wrap a key with a shared public key and your own private key
 * @param key The key to wrap
 * @param privateKey Your private key
 * @param publicKey The public key to wrap with
 * @param derivationSalt The salt to use for key derivation
 * @param curve The curve to use for key derivation
 * @param charSize The character size to use for normalization
 * @param opts The options for wrapping
 * @returns The wrapped key as a CipherText (which is just an ArrayBuffer)
 */
export declare function wrapKey(key: CryptoKey, privateKey: PrivateKey, publicKey: PublicKey, derivationSalt: ArrayBuffer, curve?: EccCurve, hashAlg?: HashAlg, opts?: Partial<SymmKeyOpts>): Promise<CipherText>;
/**
 * Unwrap a key with a shared public key and your own private key
 * @param key The key to unwrap
 * @param privateKey Your private key
 * @param publicKey The public key to unwrap with
 * @param derivationSalt The salt to use for key derivation
 * @param unwrappedKeyAlgParams The algorithm parameters for the unwrapped key
 * @param extractable Whether or not the unwrapped key is extractable
 * @param keyUsages The key usages for the unwrapped key
 * @param curve The curve to use for key derivation
 * @param charSize The character size to use for normalization
 * @param opts The options for unwrapping
 * @returns The unwrapped key as a CryptoKey
 */
export declare function unwrapKey(key: CipherText, privateKey: PrivateKey, publicKey: PublicKey, derivationSalt: ArrayBuffer, unwrappedKeyAlgParams: AlgorithmIdentifier, extractable: boolean, keyUsages: KeyUsage[], curve?: EccCurve, hashAlg?: HashAlg, opts?: Partial<SymmKeyOpts>): Promise<CryptoKey>;
declare const _default: {
    sign: typeof sign;
    verify: typeof verify;
    encrypt: typeof encrypt;
    decrypt: typeof decrypt;
    wrapKey: typeof wrapKey;
    unwrapKey: typeof unwrapKey;
};
export default _default;

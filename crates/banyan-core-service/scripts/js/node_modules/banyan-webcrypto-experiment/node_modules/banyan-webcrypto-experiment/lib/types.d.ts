export declare type Msg = ArrayBuffer | string | Uint8Array;
export declare type CipherText = ArrayBuffer;
export declare type SymmKey = CryptoKey;
export declare type SymmWrappingKey = CryptoKey;
export declare type PublicKey = CryptoKey;
export declare type PrivateKey = CryptoKey;
export declare type Config = {
    exchangeAlg: string;
    writeAlg: string;
    curve: EccCurve;
    symmAlg: SymmAlg;
    symmKeyLength: SymmKeyLength;
    hashAlg: HashAlg;
    charSize: CharSize;
    storeName: string;
    exchangeKeyPairName: string;
    writeKeyPairName: string;
    escrowKeyName: string;
};
export declare type EscrowedKeyPair = {
    publicKeyStr: string;
    wrappedPrivateKeyStr: string;
};
export declare type SymmKeyOpts = {
    alg: SymmAlg;
    length: SymmKeyLength;
    iv: ArrayBuffer;
};
export declare enum ExportKeyFormat {
    PKCS8 = "pkcs8",
    SPKI = "spki",
    RAW = "raw"
}
export declare enum CryptoSystem {
    ECC = "ecc"
}
export declare enum EccCurve {
    P_384 = "P-384"
}
export declare enum SymmAlg {
    AES_GCM = "AES-GCM",
    AES_KW = "AES-KW"
}
export declare enum SymmKeyLength {
    B256 = 256,
    B384 = 384,
    B512 = 512
}
export declare enum HashAlg {
    SHA_256 = "SHA-256",
    SHA_384 = "SHA-384",
    SHA_512 = "SHA-512"
}
export declare enum CharSize {
    B8 = 8,
    B16 = 16
}
export declare enum KeyUse {
    Exchange = "exchange",
    Write = "write"
}
export interface KeyStore {
    cfg: Config;
    keyExists(keyName: string): Promise<boolean>;
    keyPairExists(keyPairName: string): Promise<boolean>;
    deleteKey(keyName: string): Promise<void>;
    destroy(): Promise<void>;
    getExchangeKeyPair: () => Promise<CryptoKeyPair>;
    getWriteKeyPair: () => Promise<CryptoKeyPair>;
    deriveEscrowKey(passphrase: string, saltStr?: string, cfg?: Partial<Config>): Promise<string>;
    genSymmKey(keyName: string, uses: KeyUsage[], cfg?: Partial<Config>): Promise<void>;
    importSymmKey(keyStr: string, keyName: string, uses: KeyUsage[], cfg?: Partial<Config>): Promise<void>;
    getSymmKey(keyName: string): Promise<CryptoKey>;
    exportSymmKey(keyName: string): Promise<string>;
    encryptWithSymmKey(msg: string, keyName: string, cfg?: Partial<Config>): Promise<string>;
    decryptWithSymmKey(cipherText: string, keyName: string, cfg?: Partial<Config>): Promise<string>;
    wrapKeyWithSymmKey(keyToWrap: CryptoKey, keyName: string, cfg?: Partial<Config>): Promise<CipherText>;
    unwrapKeyWithSymmKey(wrappedKey: CipherText, keyName: string, keyParams: AlgorithmIdentifier, extractable: boolean, uses: KeyUsage[], cfg?: Partial<Config>): Promise<CryptoKey>;
}

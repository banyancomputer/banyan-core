import config from '../config.js';
import IDB from '../idb.js';
import { ECCNotEnabled } from '../errors.js';
import ecc from '../ecc/index.js';
import utils from '../utils.js';
import KeyStoreBase from '../keystore/base.js';
import { KeyUse, } from '../types.js';
import { DEFAULT_SYMM_ALG } from '../constants.js';
export default class ECCKeyStore extends KeyStoreBase {
    static async init(maybeCfg) {
        const eccEnabled = await config.eccEnabled();
        if (!eccEnabled) {
            throw ECCNotEnabled;
        }
        const cfg = config.normalize({
            ...(maybeCfg || {}),
        });
        const { storeName } = cfg;
        const store = IDB.createStore(storeName);
        return new ECCKeyStore(cfg, store);
    }
    // Key Pair Generation
    async genExchangeKeyPair(cfg) {
        const mergedCfg = config.merge(this.cfg, cfg);
        await IDB.createIfDoesNotExist(this.cfg.exchangeKeyPairName, () => ecc.genKeyPair(mergedCfg.curve, KeyUse.Exchange), this.store);
    }
    async genWriteKeyPair(cfg) {
        const mergedCfg = config.merge(this.cfg, cfg);
        await IDB.createIfDoesNotExist(this.cfg.writeKeyPairName, () => ecc.genKeyPair(mergedCfg.curve, KeyUse.Write), this.store);
    }
    // Public Key Exporters
    async exportPublicExchangeKey() {
        const keyPair = await this.getExchangeKeyPair();
        return ecc.exportPublicKey(keyPair.publicKey);
    }
    async exportPublicWriteKey() {
        const keyPair = await this.getWriteKeyPair();
        return ecc.exportPublicKey(keyPair.publicKey);
    }
    // Private Key Escrowers
    async exportEscrowedPrivateExchangeKey(cfg) {
        const mergedCfg = config.merge(this.cfg, cfg);
        const keyPair = await this.getExchangeKeyPair();
        const escrowKey = await this.getSymmKey(mergedCfg.escrowKeyName);
        return await ecc.exportEscrowedPrivateKey(keyPair.privateKey, escrowKey);
    }
    async exportEscrowedPrivateWriteKey(cfg) {
        const mergedCfg = config.merge(this.cfg, cfg);
        const keyPair = await this.getWriteKeyPair();
        const escrowKey = await this.getSymmKey(mergedCfg.escrowKeyName);
        return await ecc.exportEscrowedPrivateKey(keyPair.privateKey, escrowKey);
    }
    async importEscrowedWriteKeyPair(publicKey, escrowedPrivateKey, cfg) {
        const mergedCfg = config.merge(this.cfg, cfg);
        const escrowKey = await this.getSymmKey(mergedCfg.escrowKeyName);
        await IDB.createIfDoesNotExist(this.cfg.writeKeyPairName, async () => ecc.importEscrowedKeyPair(publicKey, escrowedPrivateKey, escrowKey, mergedCfg.curve, KeyUse.Write), this.store);
    }
    async importEscrowedExchangeKeyPair(publicKey, escrowedPrivateKey, cfg) {
        const mergedCfg = config.merge(this.cfg, cfg);
        const escrowKey = await this.getSymmKey(mergedCfg.escrowKeyName);
        await IDB.createIfDoesNotExist(this.cfg.exchangeKeyPairName, async () => ecc.importEscrowedKeyPair(publicKey, escrowedPrivateKey, escrowKey, mergedCfg.curve, KeyUse.Exchange), this.store);
    }
    // Key Operations
    async sign(msg, cfg) {
        const mergedCfg = config.merge(this.cfg, cfg);
        const writeKey = await this.getWriteKeyPair();
        return utils.arrBufToBase64(await ecc.sign(msg, writeKey.privateKey, mergedCfg.charSize, mergedCfg.hashAlg));
    }
    async verify(msg, sig, publicKey, cfg) {
        const mergedCfg = config.merge(this.cfg, cfg);
        const importedPublicKey = await ecc.importPublicKey(publicKey, mergedCfg.curve, KeyUse.Write);
        return ecc.verify(msg, sig, importedPublicKey, mergedCfg.charSize, mergedCfg.hashAlg);
    }
    async encrypt(msg, publicKey, b64DerivationSaltStr, cfg) {
        const mergedCfg = config.merge(this.cfg, cfg);
        const derivationSalt = utils.base64ToArrBuf(b64DerivationSaltStr);
        const symmKeyOpts = config.symmKeyOpts(mergedCfg);
        const exchangeKey = await this.getExchangeKeyPair();
        const importedPublicKey = await ecc.importPublicKey(publicKey, mergedCfg.curve, KeyUse.Exchange);
        return utils.arrBufToBase64(await ecc.encrypt(msg, exchangeKey.privateKey, importedPublicKey, derivationSalt, mergedCfg.curve, mergedCfg.hashAlg, mergedCfg.charSize, symmKeyOpts));
    }
    async decrypt(cipherText, publicKey, derivationSaltStr, cfg) {
        const mergedCfg = config.merge(this.cfg, cfg);
        const symmKeyOpts = config.symmKeyOpts(mergedCfg);
        const derivationSalt = utils.base64ToArrBuf(derivationSaltStr);
        const exchangeKey = await this.getExchangeKeyPair();
        const importedPublicKey = await ecc.importPublicKey(publicKey, mergedCfg.curve, KeyUse.Exchange);
        return utils.arrBufToStr(await ecc.decrypt(cipherText, exchangeKey.privateKey, importedPublicKey, derivationSalt, mergedCfg.curve, mergedCfg.hashAlg, symmKeyOpts), mergedCfg.charSize);
    }
    async wrapKey(key, publicKey, derivationSaltStr, cfg) {
        const mergedCfg = config.merge(this.cfg, cfg);
        const symmKeyOpts = config.symmKeyOpts(mergedCfg);
        const derivationSalt = utils.base64ToArrBuf(derivationSaltStr);
        const exchangeKey = await this.getExchangeKeyPair();
        const importedPublicKey = await ecc.importPublicKey(publicKey, mergedCfg.curve, KeyUse.Exchange);
        return await ecc.wrapKey(key, exchangeKey.privateKey, importedPublicKey, derivationSalt, mergedCfg.curve, mergedCfg.hashAlg, symmKeyOpts);
    }
    async unwrapKey(wrappedKey, publicKey, derivationSaltStr, keyParams = { name: DEFAULT_SYMM_ALG }, extractable = false, uses = ['encrypt', 'decrypt'], cfg) {
        const mergedCfg = config.merge(this.cfg, cfg);
        const symKeyOpts = config.symmKeyOpts(mergedCfg);
        const exchangeKey = await this.getExchangeKeyPair();
        const importedPublicKey = await ecc.importPublicKey(publicKey, mergedCfg.curve, KeyUse.Exchange);
        return await ecc.unwrapKey(wrappedKey, exchangeKey.privateKey, importedPublicKey, utils.base64ToArrBuf(derivationSaltStr), keyParams, extractable, uses, mergedCfg.curve, mergedCfg.hashAlg, symKeyOpts);
    }
}
//# sourceMappingURL=keystore.js.map
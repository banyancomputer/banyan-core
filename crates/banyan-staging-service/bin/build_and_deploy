#!/usr/bin/env bash

set -o errexit

cd $(dirname %0)

# Should probably make these configurable or source them from the project...
DEPLOY_HOST="distributor.data.banyan.computer"
DEPLOY_BASE_FOLDER="containers"

SERVICE_NAME="${1:-banyan-staging-service}"
SERVICE_PORT="${2:-3000}"
SERVICE_ARGUMENTS="--auth-key /data/platform-auth.key --verifier-key /data/platform-verifier.public --upload-dir /data/uploads"
SERVICE_FEATURES="postgres"

# Everything beyond this point isn't expected to be changed between services

ORG="banyan.computer"
NAMESPACE="platform"
IMAGE="${SERVICE_NAME}"

DEPLOY_IMAGE_ARCHIVE="${DEPLOY_BASE_FOLDER}/library"
DEPLOY_ENV="${DEPLOY_BASE_FOLDER}/env"
DEPLOY_LOGS="${DEPLOY_BASE_FOLDER}/logs"
DEPLOY_PERSISTENT_DATA="${DEPLOY_BASE_FOLDER}/data"
DEPLOY_SERVICE_DIRECTORY="${DEPLOY_BASE_FOLDER}/services"
DEPLOY_STATE="${DEPLOY_BASE_FOLDER}/state"

if ! git diff-index --quiet HEAD -- || ! git diff-files --quiet; then
  echo "!!> Branch is dirty, can't build and deploy from this branch"
  exit 1
fi

COMMIT_ID="$(git describe --always --dirty --long --tags)"
# Use the latest commit timestamp as its consistent, and reproducible
TIMESTAMP="$(git show -s --date=format:'%Y%m%d-%H%M%S' --format=%cd)"

IMAGE_BASE_NAME="${NAMESPACE}_${IMAGE}_${TIMESTAMP}_${COMMIT_ID}"
FULL_IMAGE_NAME="${ORG}/${NAMESPACE}/${IMAGE}:${COMMIT_ID}"

TMP_IMAGE="$(mktemp /tmp/${SERVICE_NAME}.XXXXX.tar)"

CONTAINER_RUNTIME="podman"
if which docker &> /dev/null; then
  CONTAINER_RUNTIME="docker"
fi

# Create the actual container
cp -f ../../Cargo.lock ./
${CONTAINER_RUNTIME} build -t ${FULL_IMAGE_NAME} \
  --build-arg CI_BUILD_REF=${COMMIT_ID} \
  --build-arg FEATURES=${SERVICE_FEATURES} \
  --build-arg SERVICE_NAME=${SERVICE_NAME} .
rm -f Cargo.lock

${CONTAINER_RUNTIME} save -o ${TMP_IMAGE} ${FULL_IMAGE_NAME} &>/dev/null

echo '==> Image successfully built and exported'

TMP_SERVICE="$(mktemp /tmp/${SERVICE_NAME}.XXXXX.service)"
VERSIONED_SVC_NAME="${SERVICE_NAME}-${TIMESTAMP}-${COMMIT_ID}"

cat << EOF > ${TMP_SERVICE}
[Unit]
Description=${SERVICE_NAME}
After=network-online.target
Wants=network-online.target

[Service]
Type=forking
Restart=on-failure
TimeoutStopSec=35
ExecStartPre=rm -f %t/%n-pid %t/%n-cid
ExecStartPre=podman load --input \${HOME}/${DEPLOY_IMAGE_ARCHIVE}/${IMAGE_BASE_NAME}.tar
ExecStart=podman run -d --name ${SERVICE_NAME} --read-only --replace --restart=on-failure:3 --env-file \${HOME}/${DEPLOY_ENV}/${SERVICE_NAME} --mount type=bind,src=\${HOME}/${DEPLOY_PERSISTENT_DATA}/${SERVICE_NAME},dst=/data --userns keep-id:uid=65532,gid=65532 --network slirp4netns:allow_host_loopback=true --log-driver=k8s-file --log-opt max-size=128kb,path=\${HOME}/${DEPLOY_LOGS}/${SERVICE_NAME}/latest.log --hostname ${SERVICE_NAME}.svc.${DEPLOY_HOST} --publish ${SERVICE_PORT}:3000/tcp --conmon-pidfile %t/%n-pid --cidfile %t/%n-cid ${FULL_IMAGE_NAME} ${SERVICE_ARGUMENTS}
# If we want to replicate the k8s behavior wait-drain-and-shutdown, this is what we'd use to stop the service
#ExecStop=podman stop -t 30 --cidfile %t/%n-cid
# These servers don't have alternate services picking up its downtime so we want to take the fast restart path
ExecStop=podman kill --signal=SIGINT --cidfile %t/%n-cid
PIDFile=%t/%n-pid

[Install]
WantedBy=default.target
EOF
echo '==> Service definition successfully generated'

# Transfer the container archive to the remote host
ssh ${DEPLOY_HOST} "mkdir -p \${HOME}/${DEPLOY_IMAGE_ARCHIVE} \${HOME}/${DEPLOY_SERVICE_DIRECTORY}/${SERVICE_NAME}"
scp -O ${TMP_IMAGE} ${DEPLOY_HOST}:${DEPLOY_IMAGE_ARCHIVE}/${IMAGE_BASE_NAME}.tar
scp -O ${TMP_SERVICE} ${DEPLOY_HOST}:${DEPLOY_SERVICE_DIRECTORY}/${SERVICE_NAME}/${VERSIONED_SVC_NAME}.service
rm -f ${TMP_IMAGE} ${TMP_SERVICE}

echo '==> Transferred new version to service host'

ssh -T ${DEPLOY_HOST} <<EOS
nohup sh -c "\
  set -o errexit

  mkdir -p ${DEPLOY_ENV} ${DEPLOY_STATE} ${DEPLOY_LOGS}/${SERVICE_NAME} ${DEPLOY_PERSISTENT_DATA}/${SERVICE_NAME}
  touch ${DEPLOY_ENV}/${SERVICE_NAME}
  chmod -R u=rwX,g=,o= ${DEPLOY_ENV}/${SERVICE_NAME} ${DEPLOY_PERSISTENT_DATA}/${SERVICE_NAME}

  echo '##> Overwriting current version with new service data...'
  mkdir -p "\${HOME}/.config/systemd/user"

  cp -f "${DEPLOY_SERVICE_DIRECTORY}/${SERVICE_NAME}/${VERSIONED_SVC_NAME}.service" "\${HOME}/.config/systemd/user/${SERVICE_NAME}.service"
  systemctl --user daemon-reload

  if systemctl --user is-enabled --quiet ${SERVICE_NAME}.service; then
    echo '##> Service is enabled lets meddle...'

    if systemctl --user is-active --quiet ${SERVICE_NAME}.service; then
      echo '##> Service is running, attempting a restart...'

      if ! systemctl --user restart ${SERVICE_NAME}.service &>/dev/null; then
        echo '##> Service failed to start...'

        if [ -L "${DEPLOY_STATE}/${SERVICE_NAME}.service" ]; then
          echo '##> Previous version available, attempting to revert...'

          cp -Lf "${DEPLOY_STATE}/${SERVICE_NAME}.service" "\${HOME}/.config/systemd/user/${SERVICE_NAME}.service"

          systemctl --user daemon-reload
          systemctl --user restart ${SERVICE_NAME}.service

          echo '##> Reverted successfully'
        else
          echo '##> No recovery version available'
        fi

        echo '##> Deploy failed'
        exit 1
      fi

      systemctl --user enable ${SERVICE_NAME}.service

      echo '##> Service appears to be healthy'
    else
      echo '##> Attempting to start failed service...'
      systemctl --user start ${SERVICE_NAME}.service &>/dev/null
      echo '##> Service successfully started'
    fi

    echo '##> Marking the new version as current'

    if [ -L "${DEPLOY_STATE}/${SERVICE_NAME}.service" ]; then
      mv "${DEPLOY_STATE}/${SERVICE_NAME}.service" "${DEPLOY_STATE}/${SERVICE_NAME}.service.last"
    fi

    ln -frs "${DEPLOY_SERVICE_DIRECTORY}/${SERVICE_NAME}/${VERSIONED_SVC_NAME}.service" "${DEPLOY_STATE}/${SERVICE_NAME}.service"

    echo '##> Cleaning up old images...'
    podman image prune -f
  else
    echo '##> Service isnt enabled not starting...'
  fi
"
EOS

echo '==> Deployed'
